# 多线程和异步





## 回顾Java中的多线程

### 继承Thread类

- 继承Thread类

  ```java
  package com.xuelingmiao.threadtest.threads;
  
  import android.util.Log;
  
  public class MyThread extends Thread {
      private static final String TAG = "MyThread";
  	//重写run方法
      @Override
      public void run() {
          super.run();
          //需要执行的任务
          Log.d(TAG, "run: "+Thread.currentThread().getName());
      }
  }
  
  ```

  

- 启动线程

  ```java
   public void TestMyThread(){
       	//实例化继承了Thread的类
          Thread t1 = new MyThread();
          Thread t2 = new MyThread();
          t1.start();	//启动线程。
          t2.start();
      }
  ```

- 执行结果

  ![image-20201218134109957](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218134109957.png)

  

### 实现Runnable接口

如果当前类，已经继承其它类，但是我们又需要多线程就可以使用实现Runnable方式来实现。

- 实现Runnable接口

  ```java
  package com.xuelingmiao.threadtest.threads;
  
  import android.util.Log;
  
  public class MyRunnable implements Runnable {
      private static final String TAG = "MyRunnable";
      //重写run方法
      @Override
      public void run() {
          //要执行的任务
          Log.d(TAG, "run: "+Thread.currentThread().getName());
      }
  }
  
  ```

  

- 启动线程

  ```java
   public void TestRunnable(){
       	//实例实现了Runnable接口的类。
          MyRunnable runnable1 = new MyRunnable();
          MyRunnable runnable2 = new MyRunnable();
       	// 实例Thread类，并传递任务
          Thread t1 = new Thread(runnable1);
          Thread t2 = new Thread(runnable2);
       	//启动线程
          t1.start();
          t2.start();
      }
  ```

  

- 执行结果

  ![image-20201218135201196](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218135201196.png)

### 线程同步

多个Thread执行同一个Runnable。如生活中购买火车票，不同的人去抢购同一地域的火车票。我们可以把这里的人看作为Thread（线程）火车票看作为Runnable.

在多个线程,操作同一个任务时我们需要**锁🔒对象**来保证线程不出现问题。



**案例；**

多个线程去出售同一批火车票。

- 编写售票任务。把需要同步操作的代码使用同步代码块包裹。

  ```java
  package com.xuelingmiao.threadtest.threads.cases;
  
  import android.util.Log;
  
  public class SaleTicket implements Runnable {
      private static final String TAG = "SaleTicket";
      private int ticket = 20;	//总票数
  
      @Override
      public void run() {
          while (true) {
              //使用同步代码块，这里索对象使用this
              synchronized (this) {
                  //有票
                  if (ticket > 0) {
                      Log.d(TAG, "run: " + Thread.currentThread().getName() + "卖出了第" + (20 - ticket + 1) + "张");
                      ticket--; //每卖出一张总票数-1
                  }
                  //无票，结束循环。
                  else {
                      break;
                  }
              }
              // 休息一会在买票。
              try {
                  Thread.sleep(500);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
  
  
      }
  }
  
  ```

  

- 交给不同线程去售卖。

  ```java
      public void testSaleTicket(){
          //实例化售票任务。
          SaleTicket saleTicket = new SaleTicket();
          //分别交给不同线程去售卖。
          Thread t1 = new Thread(saleTicket,"{代理A|");
          Thread t2 = new Thread(saleTicket,"{代理B|");
          Thread t3 = new Thread(saleTicket,"{代理C|");
          Thread t4 = new Thread(saleTicket,"{代理D|");
          //启动任务。
          t1.start();
          t2.start();
          t3.start();
          t4.start();
      }
  ```

  

- 执行结果

  ![image-20201218144641511](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218144641511.png)



## 线程池



### 缓存线程池【CachedThreadPool】

是一个按需创建的线程池对象，根据当前任务数自动创建和重用线程。每个线程空闲等待的时间为60s

**创建；**

```java
 ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
```

**使用；**

模拟一个线程任务。为了体现，在执行任务时是使用的同一个线程，这里我们让线程休息一下，来达到非并发添加线程。一个一个添加任务到线程池中。

- `execute(Runnable runnable)`  执行任务。
  - 参数；
    - `Runnable runnable` 一个Runnable接口。

```java
public void testCache(){
        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            //模拟一个空闲时间
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //添加任务到线程池。
            cachedThreadPool.execute(new Runnable() {
                @Override
                public void run() {
                    Log.d(TAG, "run: 执行任务"+Thread.currentThread().getName()+"第"+index+"任务");
                }
            });
        }
    }
```

执行结果；可以看到当前的任务都是同一个线程来完成的。（pool-1-thread-1）

![image-20201218202346646](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218202346646.png)



### 固定线程池【FixedThreadPool】

一个可以控制并发（同时执行）的线程池。同时固定线程池长度。

**创建；**

Executors类中的创建方法：

- `Executors.newFixedThreadPool(int corePoolSize)`创建可重用固定线程数
  - 参数
    - `int corePoolSize` 核心线程数及同时执行线程个数。
  - 返回值
    - ExecutorService

```java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
```



**使用；**

```java
 public void testFixedThreadPool() {
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) {
            final int index = i;
            fixedThreadPool.execute(new Runnable() {
                @Override
                public void run() {
                    Log.d(TAG, "run: " + Thread.currentThread().getName() + "当前执行的任务是" + index);
                    //同时让每一个执行到这里的线程休眠一下。
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
```



执行结果；可以看到这里的最高并发数量只有到3.运行上面的代码会出现一次有三个任务同时执行的效果，之后这三个任务会同时休眠一会。

![image-20201218204130503](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218204130503.png)



### 单线程【SingleThreadExecutor】

只会用一个工作线程来执行任务，保证所有的任务按指定的优先级顺序来执行。

**创建；**

```java
 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
```

**使用；**

```java
 public void testSingleThreadExecutor(){
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 10; i++) {
            final int index = i;
            singleThreadExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    Log.d(TAG, "run: "+Thread.currentThread().getName()+"执行任务"+index);
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
```

执行结果； 可以看到始终只有一个Thread（pool-1-thread-1）在执行。任务

![image-20201218210258617](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218210258617.png)



### 定时延时执行【ScheduledThreadPool】

支持指定长度的，线程池同时支持定时执行任务和周期（按指定的时间间距执行任务）执行任务。

**创建；**

```java
ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();
```



**使用；**

延迟执行惹任务。

- `schedule(Runnable var1, long var2, TimeUnit var4)` 延迟执行任务。
  - 参数；
    - `Runnable var1` 要执行的任务。
    - `long var2 ` 延迟时间。
    -  `TimeUnit var4 ` 延迟的时间单位。
- `scheduleAtFixedRate(Runnable var1, long var2, long var4, TimeUnit var6)` 延迟周期任务。
  - 参数；
    - Runnable var1 要执行的任务。
    - long var2  延迟首次执行的时间。
    - long var4  连续执行的周期时间。
    - TimeUnit var6  延迟和周期的时间单位。
- `shutdown()` 结束周期定时。

 ```java
 public void testSingleThreadScheduledExecutor(){
        Log.d(TAG, "test: 三秒后将执行任务");
        ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();
     //延迟执行任务。
        singleThreadScheduledExecutor.schedule(new Runnable() {
            @Override
            public void run() {
                Log.d(TAG, "run: "+Thread.currentThread().getName()+"模拟任务");
            }
        },3, TimeUnit.SECONDS);
     
     //周期执行任务。
     singleThreadScheduledExecutor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                Log.d(TAG, "run: 模拟任务"+Thread.currentThread().getName());
            }
        },2,3,TimeUnit.SECONDS);
     
     
     
    }
 ```

执行结果；

![image-20201218212849967](%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1-images/image-20201218212849967.png)





## 线程池部分方法

- `shutDown()` 关闭线程池，不影响已经提交的任务
- `shutDownNow()` 关闭线程池，并尝试去终止正在执行的线程
- `allowCoreThreadTimeOut(boolean value) 允许`核心线程闲置超时时被回收
- `submit()` 一般情况下我们使用execute来提交任务，但是有时候可能也会用到submit，使用submit的好处是submit有返回值。
- `execute(runnable)` 执行任务
- `beforeExecute()` - 任务执行前执行的方法
- `afterExecute()` -任务执行结束后执行的方法
- `terminated()` -线程池关闭后执行的方法





